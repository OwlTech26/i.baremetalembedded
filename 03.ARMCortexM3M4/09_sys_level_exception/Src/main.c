/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

extern void initialise_monitor_handles(void);

#define SVC_MATH_ENABLE
#ifdef SVC_MATH_ENABLE
#define SVC_MATH_ADD	(36u)
#define SVC_MATH_SUB	(37u)
#define SVC_MATH_MUL	(38u)
#define SVC_MATH_DIV	(39u)
#endif /* SVC_MATH_ENABLE */

int add_nums(const int x, const int y);
int sub_nums(const int x, const int y);
int mul_nums(const int x, const int y);
int div_nums(const int x, const int y);


int add_nums(const int x, const int y)
{
	// Triger SVC exception
	__asm volatile("SVC #36");
	const register uint32_t ret_res __asm("r0");

	return ret_res;
}

int sub_nums(const int x, const int y)
{
	// Triger SVC exception
	__asm volatile("SVC #37");
	const register uint32_t ret_res __asm("r0");

	return ret_res;
}

int mul_nums(const int x, const int y)
{
	// Triger SVC exception
	__asm volatile("SVC #38");
	const register uint32_t ret_res __asm("r0");

	return ret_res;
}

int div_nums(const int x, const int y)
{
	// Triger SVC exception
	__asm volatile("SVC #39");
	const register uint32_t ret_res __asm("r0");

	return ret_res;
}

int main(void)
{
	initialise_monitor_handles();

	printf("=== STM32 System Level Exception Services! ===\n");

#ifdef SVC_MATH_ENABLE
	const int x = 40;
	const int y = -90;
	int32_t res = add_nums(x, y);
	printf("Result(+) = %ld\n", res);
	res = sub_nums(x, y);
	printf("Result(-) = %ld\n", res);
	res = mul_nums(x, y);
	printf("Result(*) = %ld\n", res);
	res = div_nums(x, y);
	printf("Result(/) = %ld\n", res);


#else
	// Triger SVC exception
	__asm("SVC #0x08");

	// Retrieve updated SVC value from handler
#if 0
	const register uint32_t svc_data __asm("r0");
#else
	uint32_t svc_data = 0u;
	__asm volatile("MOV %0,R0": "=r"(svc_data) ::);
#endif
	printf("New SVC value: %lu\n", svc_data);
#endif /* SVC_MATH_ENABLE */

	for(;;);
}

__attribute((naked)) void SVC_Handler(void)
{
	// 1. Get the value of MSP
	__asm("MRS R0,MSP");
	// According to the procedure call standard R0-R15 will be handed over to the callee as parameters
	__asm("B SVC_Handler_c");
}


#ifdef SVC_MATH_ENABLE
void SVC_Handler_c(uint32_t * const p_stack_frame_base)
{
	printf("--- SVC HANDLER ---\n");

	/** Stack Frame
	 *  [7] xPSR
	 *  [6] PC (return address)
	 *  [5] LR
	 *  [4] R12
	 *  [3] R3
	 *  [2] R2
	 *  [1] R1
	 *  [0] R0 (MSP) <--
	 */

	// Fetch SVC value
	const uint8_t * const p_ret_addr = (const uint8_t * const)p_stack_frame_base[6u]; // Return address
	const uint8_t svc_val = *(p_ret_addr - 2u); // Decrement the return address by 2 to point to opcode of the SVC instruction in the program memory
	const int32_t x = p_stack_frame_base[0u]; // R0
	const int32_t y = p_stack_frame_base[1u]; // R1
	int32_t result = 0;

	switch (svc_val) {
		case SVC_MATH_ADD:
			result = x + y;
			printf(" -> SVC Addition(%u): %ld + %ld = %ld\n", svc_val, x, y, result);
			break;
		case SVC_MATH_SUB:
			result = x - y;
			printf(" -> SVC Subtraction(%u): %ld - %ld = %ld\n", svc_val, x, y, result);
			break;
		case SVC_MATH_MUL:
			result = x * y;
			printf(" -> SVC Multiplication(%u): %ld * %ld = %ld\n", svc_val, x, y, result);
			break;
		case SVC_MATH_DIV:
			result = x / y;
			printf(" -> SVC Division(%u): %ld / %ld = %ld\n", svc_val, x, y, result);
			break;
		default:
			printf("Undefined SVC operation(%u)\n", svc_val);
			break;
	}

	// Return result via R0
	p_stack_frame_base[0u] = result;
}
#else
void SVC_Handler_c(uint32_t * const p_stack_frame_base)
{
	printf("--- SVC HANDLER ---\n");

	/** Stack Frame
	 *  [7] xPSR
	 *  [6] PC (return address)
	 *  [5] LR
	 *  [4] R12
	 *  [3] R3
	 *  [2] R2
	 *  [1] R1
	 *  [0] R0 (MSP) <--
	 */
	const uint8_t * const p_ret_addr = (const uint8_t * const)p_stack_frame_base[6u];
	printf("ret_addr: %p\n", p_ret_addr);

	// 2. Decrement the return address by 2 to point to opcode of the SVC instruction in the program memory
	const uint8_t * const p_svc_addr = p_ret_addr - 2u;
	printf("svc_addr: %p, svc_val: %u\n", p_svc_addr, *p_svc_addr);

	// 3. Return changed SVC value
	p_stack_frame_base[0u] = *p_svc_addr + 4u;
}
#endif /* SVC_MATH_ENABLE */
