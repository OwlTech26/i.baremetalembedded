/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>

#include "main.h"
#include "led.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


static t_task_register USER_TASK;

static inline void debug_memory_dump(const uint32_t addr, const uint8_t length);
static inline void debug_stack_frame_dump(const uint32_t sf_addr);

void enable_processor_faults(void);

NAKED_FUNC void init_scheduler_stack(const uint32_t stack_sched_top);
void init_task_register(t_task_register * const p_task_reg, const uint32_t task_psp[TASKS_MAX], const uint32_t task_hlr[TASKS_MAX]);
void init_task_stack(t_task_register * const p_task_reg);
void init_systick_timer(const uint32_t tick_hz);
NAKED_FUNC void switch_sp_to_psp(void);

const uint32_t get_psp_value(void);
void set_psp_value(const uint32_t stack_addr);
void update_next_task(void);
void update_global_tick_count(void);
void unblock_tasks(void);
void schedule(void);
void task_delay(const uint32_t tick_count);
void task_idle(void);
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

static inline void debug_memory_dump(const uint32_t addr, const uint8_t length)
{
	printf("--- MEMORY: %#lX(%u) ---\n", addr, length);
	const uint32_t addr_end = addr + (length * WORDS);
	if (addr_end < SRAM_END_BASE) {
		for (uint32_t i=0u; i<length; ++i) {
			const uint32_t curr_addr = addr + (i * WORDS);
			const uint32_t data = *(uint32_t *)curr_addr;
			printf("%lu [%#lX] = %#lX\n", i, curr_addr, data);
		}
	} else {
		printf(" -> [ERROR] Out of bounds '%#lX' from SRAM (%#X)\n", addr_end, SRAM_END_BASE);
	}
}

static inline void debug_stack_frame_dump(const uint32_t sf_addr)
{
	static const char * context_params[CONTEXT_PARAMS_MAX] = {
		[0]  = "XPSR",
		[1]  = "PC",
		[2]  = "LR",
		[3]  = "R12",
		[4]  = "R3",
		[5]  = "R2",
		[6]  = "R1",
		[7]  = "R0",
		[8]  = "R11",
		[9]  = "R10",
		[10] = "R9",
		[11] = "R8",
		[12] = "R7",
		[13] = "R6",
		[14] = "R5",
		[15] = "R4"
	};

	printf("--- STACK FRAME: %#lX ---\n", sf_addr);
	if (sf_addr <= SRAM_END_BASE) {
		for (uint32_t i=0u; i<CONTEXT_PARAMS_MAX; ++i) {
			const uint32_t curr_addr = sf_addr - ((i + 1u) * WORDS);
			const uint32_t data = *(uint32_t *)curr_addr;
			printf("%2lu %4s [%#8lX] = %#8lX\n", i, context_params[i], curr_addr, data);
		}
	} else {
		printf(" -> [ERROR] Out of bounds Stack Frame '%#lX' from SRAM (%#X)\n", sf_addr, SRAM_END_BASE);
	}
}

void enable_processor_faults(void)
{
	// 1. Enable ALL configurable exceptions like: usage, memory manage and bus FAULT.
	uint32_t * const p_shcrs_reg = (uint32_t * const)SHCRS_BASE;
	*p_shcrs_reg |= ((1u << SHCRS_MEMFAULTENA) | (1u << SHCRS_BUSFAULTENA) | (1u << SHCRS_USGFAULTENA));
}

NAKED_FUNC void init_scheduler_stack(const uint32_t stack_sched_top)
{
	// Load the top of the scheduler stack pointer to MSP
	__asm volatile("MSR MSP,%0": : "r" (stack_sched_top) : ); // MSR: Move from special register to general register
	// Return from function call
	__asm volatile("BX LR"); // BX: branch indirect
}


void init_task_register(t_task_register * const p_task_reg, const uint32_t task_psp[TASKS_MAX], const uint32_t task_hlr[TASKS_MAX])
{
	for (uint32_t i=0; i<TASKS_MAX; ++i) {
		p_task_reg->task_cb[i].psp_val = task_psp[i];
		p_task_reg->task_cb[i].block_count = 0u;
		p_task_reg->task_cb[i].state = e_tst_ready;
		p_task_reg->task_cb[i].task_hlr = (void *)task_hlr[i];
	}

	p_task_reg->task_idx = 1u; // 0 is the IDLE task, start with task 1.
	p_task_reg->g_tick_count = 0u;
}

void init_task_stack(t_task_register * const p_task_reg)
{
	for (uint32_t i=0u; i<TASKS_MAX; ++i) {
		// PSP to the stack start address
		uint32_t *p_psp_curr = (uint32_t *)p_task_reg->task_cb[i].psp_val;
		// XPSR
		p_psp_curr--;
		*p_psp_curr = TASK_XPSR_DEF;
		// PC
		p_psp_curr--;
		*p_psp_curr = (uint32_t)p_task_reg->task_cb[i].task_hlr;
		// LR
		p_psp_curr--;
		*p_psp_curr = EXC_RET_THREAD_MODE_PSP_NO_FP;

		// Iterate over Rx registers in descending order: R12, R3, R2, R1, R0, R11, R10, R9, R8, R7, R6, R5, R4
		for (uint32_t j=0u; j<CONTEXT_RX_PARAMS_MAX; ++j) {
			p_psp_curr--;
			*p_psp_curr = TASK_RX_DEF;
		}

		// Save the current Task's PSP value to the register
		p_task_reg->task_cb[i].psp_val = (uint32_t)p_psp_curr;
	}
}

void init_systick_timer(const uint32_t tick_hz)
{
	// 1. Calculate systick and load as reload value
	uint32_t * const p_srvr_reg = (uint32_t * const)SYST_RVR_BASE;
	*p_srvr_reg = (SYSTICK_TIMER_CLK / tick_hz) - 1u;

	// 2. Set systick control status
	uint32_t * const p_scsr_reg = (uint32_t * const)SYST_CSR_BASE;
	*p_scsr_reg |= ((1u << 2u) | (1u << 1u)); // processor clock source | counting down to zero asserts the SysTick exception request
	*p_scsr_reg |= (1u << 0); // Enable the systick clock
}

NAKED_FUNC void switch_sp_to_psp(void)
{
	// 1. Initialize the PSP with TASK1 stack start address
	__asm volatile("PUSH {LR}"); // Preserce LR on the stack
	__asm volatile("BL get_psp_value"); // Return value will be stored in R0 according to the ARM procedure call standard
	__asm volatile("MSR PSP,R0"); // Load R0 to PSP
	__asm volatile("POP {LR}"); // Reload the saved LR because this was corrupted via the 'BL'

	// 2. Change SP to PSP in the CONTROL register
	__asm volatile("MOV R0,#0x02");
	__asm volatile("MSR CONTROL,R0");
	__asm volatile("BX LR"); // Return to Main
}

const uint32_t get_psp_value(void)
{
	const uint8_t current_task = USER_TASK.task_idx;
	return USER_TASK.task_cb[current_task].psp_val;
}

void set_psp_value(const uint32_t stack_addr)
{
	const uint8_t current_task = USER_TASK.task_idx;
	USER_TASK.task_cb[current_task].psp_val = stack_addr;
}

void update_next_task(void)
{
	t_task_state state = e_tst_block;

	for (uint32_t i=0u; i<TASKS_MAX; ++i) {
		USER_TASK.task_idx++;
		USER_TASK.task_idx %= TASKS_MAX;
		state = USER_TASK.task_cb[USER_TASK.task_idx].state;
		if ((e_tst_ready == state) && (0u != USER_TASK.task_idx)) {
			break; // The task is schedulable
		}
	}

	if (e_tst_ready != state) {
		USER_TASK.task_idx = 0u; // No enabled task, run IDLE.
	}
}

void update_global_tick_count(void)
{
	USER_TASK.g_tick_count++;
}

void unblock_tasks(void)
{
	for (uint32_t i=1u; i<TASKS_MAX; ++i) {
		if ((e_tst_ready != USER_TASK.task_cb[i].state) && (USER_TASK.task_cb[i].block_count == USER_TASK.g_tick_count)) {
			USER_TASK.task_cb[i].state = e_tst_ready;
		}
	}
}

void schedule(void)
{
	// Set PendSV
	uint32_t * const p_icsr_reg = (uint32_t *)ICSR_BASE;
	*p_icsr_reg |= (1u << ICSR_PENDSV);
}

void task_delay(const uint32_t tick_count)
{
	// DISABLE Interrupt because of concurrency between shared variables in thread vs handler mode
	INTERRUPT_DISABLE();

	const uint8_t current_task = USER_TASK.task_idx;
	if (current_task != 0u) { // Skip for IDLE task
		USER_TASK.task_cb[current_task].block_count = USER_TASK.g_tick_count + tick_count;
		USER_TASK.task_cb[current_task].state = e_tst_block;

		schedule();
	}

	// ENABLE Interrupt
	INTERRUPT_ENABLE();
}

void task_idle(void)
{
	while(1) {
		// GET CPU SLEEP
	}
}

void task1_handler(void)
{
	while(1) {
		LED_on(LED_USR);
		task_delay(1000u);
		LED_off(LED_USR);
		task_delay(1000u);
	}
}

void task2_handler(void)
{
	while(1) {
		printf("LED 2 ON\n");
		task_delay(500u);
		printf("LED 2 OFF\n");
		task_delay(500u);
	}
}

void task3_handler(void)
{
	while(1) {
		printf("LED 3 ON\n");
		task_delay(250u);
		printf("LED 3 OFF\n");
		task_delay(250u);
	}
}

void task4_handler(void)
{
	while(1) {
		printf("LED 4 ON\n");
		task_delay(125u);
		printf("LED 4 OFF\n");
		task_delay(125u);
	}
}


int main(void)
{
	printf(" --- Round-robin Scheduler for STM32 ---\n");

	// 1. Enabling Processor Faults
	enable_processor_faults();

	// 2. Initialization of the Scheduler stack
	init_scheduler_stack(STACK_START_SCHED);

	// 3. Initialization of the task register
	static const uint32_t task_psp[TASKS_MAX] = {IDLE_STACK_START, STACK_START_T1, STACK_START_T2, STACK_START_T3, STACK_START_T4};
	static const uint32_t task_hlr[TASKS_MAX] = {(uint32_t)task_idle, (uint32_t)task1_handler, (uint32_t)task2_handler, (uint32_t)task3_handler, (uint32_t)task4_handler};
	init_task_register(&USER_TASK, task_psp, task_hlr);

	// 4. Initialization of the task stack
	init_task_stack(&USER_TASK);

	// Dump stack frame
	//debug_stack_frame_dump(STACK_START_T1);

	// 5. Initialize LED
	LED_init();

	// 6. Initialization of the systick timer
	init_systick_timer(TICK_HZ);

	// 7. Switching SP to PSP stack pointer
	switch_sp_to_psp();

	// 8. Launch the first task handler
	task1_handler();

    /* Loop forever */
	for(;;);
}

NAKED_FUNC void PendSV_Handler(void)
{
	// Save the Context of the current task
	// 1. Get current running task's PSP value
	__asm volatile("MRS R0, PSP"); // Save PSP to R0

	// 2. Using that PSP store SF2 (R4...R11) - SF1 is stored by the CPU HW
	__asm volatile("STMDB R0!, {R4-R11}"); // PUSH does not allowed here, because MSP would be affected (in handler mode always the MSP is used.). Simulating PUSH.

	// 3. Save the current PSP
	__asm volatile("PUSH {LR}"); // Save the value of the link register before branching
	__asm volatile("BL set_psp_value"); // R0 will be provided according to the ARM function call procedure standard

	// Retrieve the Context of the next task
	// 1. Decide next task to run
	__asm volatile("BL update_next_task");

	// 2. Get it's past PSP value
	__asm volatile("BL get_psp_value"); // R0 keeps the PSP value according to the ARM function call procedure standard

	// 3. Retrieve SF2 (R4...R11) using that PSP - SF1 will be re-stored by the CPU HW
	__asm volatile("LDMIA R0!,{R4-R11}");

	// 4. Update PSP and exit
	__asm volatile("MSR PSP, R0"); // Load R0 to PSP
	__asm volatile("POP {LR}"); // Restore the value of the link register
	__asm volatile("BX LR"); // Exit return
}

 void SysTick_Handler(void)
{
	 // 1. Update global tick count
	 update_global_tick_count();

	 // 2. Unblock tasks
	 unblock_tasks();

	 // 3. Set PendSV
	 uint32_t * const p_icsr_reg = (uint32_t *)ICSR_BASE;
	 *p_icsr_reg |= (1u << ICSR_PENDSV);
}

void HardFault_Handler(void)
{
	printf("Exception: HardFault\n");
	while(1);
}

void MemManage_Handler(void)
{
	printf("Exception: MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception: BusManage\n");
	while(1);
}
